You don’t call the constructor — Spring does.

When you request the bean via getBean(), Spring returns an already constructed, dependency-injected object.

Because BubbleSortAlgorithm is a @Component, Spring found it, created it, and injected it.

Even though you never used new, Spring internally used your constructor (constructor injection).

		ApplicationContext applicationContext = SpringApplication.run(DemoApplication.class, args);
		
		BinarySearchImpl binarySearch = applicationContext.getBean(BinarySearchImpl.class);
		
		@Component //this is to tell spring that this class is a Bean, beans are objects that are managed by spring framework
public class BinarySearchImpl {
  //sorting an array
  //search the array
  //return the result
  
  //autowiring is the process where spring identifies the dependencies, identifies the matches for dependencies and populates them
  @Autowired//to tell spring that sortAlgorithm is a dependency
  private SortAlgorithm sortAlgorithm;//this is a dependency of BSI
  //BSI is depended on sortAlgorithm

  public BinarySearchImpl(SortAlgorithm sortAlgorithm) {//constructor used for the user to use their own algo => loosely coupled
    this.sortAlgorithm = sortAlgorithm;
  }
  
  
[SpringApplication.run()]
          │
          ▼
 ┌─────────────────────────────┐
 │   Component Scan Phase      │
 │  Finds @Component classes   │
 └─────────────────────────────┘
          │
          ▼
 ┌─────────────────────────────┐
 │  Create BubbleSortAlgorithm │
 │  Create BinarySearchImpl    │
 │    ↳ Inject BubbleSortAlgorithm
 └─────────────────────────────┘
          │
          ▼
 ┌─────────────────────────────┐
 │  Beans stored in Container  │
 │  (ApplicationContext)       │
 └─────────────────────────────┘
          │
          ▼
You call → getBean(BinarySearchImpl.class)
Spring returns → fully ready object ✅
